<html>
<head>
    <title>Q-Learning Good Times</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="pixi.js"></script>
</head>
<body>
    <script>
 
    // create an new instance of a pixi stage
    var stage = new PIXI.Stage(0x66FF99);
 
    // create a renderer instance.
    var renderer = PIXI.autoDetectRenderer(900, 420);
 
    // add the renderer view element to the DOM
    document.body.appendChild(renderer.view);
 
    requestAnimFrame( animate );

    // draw le grid
    drawHorizontalLines();
    drawVerticalLines();

    // draw le hero
    var hero = new PIXI.Graphics();
    constructHero();

 
    // draw le enemies
    var enemy1 = new PIXI.Graphics();
    constructEnemy(enemy1, 150, 30);
    var enemy2 = new PIXI.Graphics();
    constructEnemy(enemy2, 330, 210);


    // draw le goal node
    var goal = new PIXI.Graphics();
    constructGoal(goal, 860, 380);


    var updatedX = 60;
    var updatedY = 60;
    var potentialMoves = new Array(60, -60, 0);
    var zeroCoords = new Array(0, 1);

    snapshotXPos = hero.x;
    snapshotYPos = hero.y;


    // create Q table, 2d array
    var qtable = new Array(9);
    for (var qxIterator = 0; qxIterator < 9; qxIterator++){
        qtable[qxIterator] = new Array(9);
    }

    // create R table, 2d array
    var rewards = new Array(9);
    for (var rxIterator = 0; rxIterator < 9; rxIterator++){
        rewards[rxIterator] = new Array(9);
    }

    // set rewards matrix manually
    var rewards = [[ -1,  0, -1,  0, -1, -1, -1, -1, -1  ],           // 1a
                   [  0, -1,  0, -1,  0, -1, -1, -1, -1  ],           // 1b
                   [ -1,  0, -1, -1, -1,  0, -1, -1, -1  ],           // 1c
                   [  0, -1, -1, -1,  0, -1,  0, -1, -1  ],           // 2a
                   [ -1,  0, -1,  0, -1,  0, -1,  0, -1  ],           // 2b
                   [ -1, -1,  0, -1,  0, -1, -1, -1, 100 ],           // 2c
                   [ -1, -1, -1,  0, -1, -1, -1,  0, -1  ],           // 3a
                   [ -1, -1, -1, -1,  0, -1,  0, -1, 100 ],           // 3b
                   [ -1, -1, -1, -1, -1,  0, -1, 0, -1   ]]           // 3c


    function animate() {
        requestAnimFrame( animate );

        if ((hero.x != snapshotXPos + updatedX) || (hero.y != snapshotYPos + updatedY)){
            if (updatedX > 0){
                hero.x += 1;
            } else if (updatedX < 0) {
                hero.x -= 1;
            }
            if (updatedY > 0){
                hero.y += 1;
            } else if (updatedY < 0) {
                hero.y -= 1;
            }
        } else {
            // update the position for hero to travel
            snapshotXPos = hero.x;
            snapshotYPos = hero.y;

            // choose next state based on q value









/*
            // border tiles, hero cannot travel beyond map
            var hitBorderX = false;
            var hitBorderY = false;

            if (snapshotXPos < 60){
                // left border
                // remove -60 from options
                var leftBorderPotential = new Array(60, 0);
                updatedX = leftBorderPotential[Math.floor(Math.random() * leftBorderPotential.length)];
                hitBorderX = true;
            } 
            if (snapshotYPos < 60){
                // top border
                // remove -60 from options
                var topBorderPotential = new Array(60, 0);
                updatedY = topBorderPotential[Math.floor(Math.random() * topBorderPotential.length)];
                hitBorderY = true;
            }

            if (snapshotXPos > 780){
                // right border
                var rightBorderPotential = new Array(-60, 0);
                updatedX = rightBorderPotential[Math.floor(Math.random() * rightBorderPotential.length)];
                hitBorderX = true;             
            }

            if (snapshotYPos > 300){
                // bottom border
                var bottomBorderPotential = new Array(-60, 0);
                updatedY = bottomBorderPotential[Math.floor(Math.random() * bottomBorderPotential.length)];
                hitBorderY = true;
            }

            if (hitBorderX == false){
                updatedX = potentialMoves[Math.floor(Math.random() * potentialMoves.length)];                
            }
            if (hitBorderY == false){
                updatedY = potentialMoves[Math.floor(Math.random() * potentialMoves.length)];            
            }
            
            // if both coordinates aren't equal to 0, choose between one and 0 it out
            // so that hero can't move diagonally
            if ((updatedX != 0) && (updatedY != 0)){
                zeroCoord = zeroCoords[Math.floor(Math.random() * zeroCoords.length)];
                if (zeroCoord == 0){
                    updatedY = 0;
                } else {
                    updatedX = 0;
                }
            } */
        }
 
        // render the stage   
        renderer.render(stage);
    }




    /*
     *
     */
    function constructHero(){   
        // begin a green fill..
        hero.beginFill(0x000000);
        // draw a triangle using lines
        hero.moveTo(30,15);
        hero.lineTo(20, 45);
        hero.lineTo(40, 45);
        // end the fill
        hero.endFill();
        // add it the stage so we see it on our screens..
        stage.addChild(hero);
    }

    /*
     *
     */
    function constructEnemy(e, x, y){
        // begin fill
        e.beginFill(0x000000);
        // draw a circle
        e.moveTo(x, y);
        e.drawCircle(x, y, 12);
        e.endFill();
        stage.addChild(e);   
    }

    /*
     *
     */
     function constructGoal(g, x, y){
        g.beginFill(0x000000);
        g.moveTo(x, y);
        g.drawRect(x, y, 20, 20);
        g.endFill();
        stage.addChild(g);
     }

    /*
     *  draw horizontal lines
     */
    function drawHorizontalLines() {
        var addingElements = true;
        var yPos = 60;
        var horizIteration = 0;
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics(); 
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(0,yPos);
            graphics.drawRect(0, yPos, 900, 2);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            horizIteration += 1;
            yPos += 60;
            if (horizIteration >= 6){
                addingElements = false;
            }
        }
    }

    /*
     * draw vertical lines
     */
    function drawVerticalLines(){
        addingElements = true;
        var xPos = 60;
        var vertIteration = 0;
        // draw vertical lines
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics();
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(xPos,0);
            graphics.drawRect(xPos, 0, 2, 420);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            vertIteration += 1;
            xPos += 60;
            if (vertIteration >= 15){
                addingElements = false;
            }    
        }
    }
 
    </script>
 
    </body>
</html>