<html>
<head>
    <title>Q-Learning Good Times</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="pixi.js"></script>
</head>
<body>
    <script>
 
    // create an new instance of a pixi stage
    var stage = new PIXI.Stage(0xffffff);

    // create scrolling background images
    var spaceTexture = PIXI.Texture.fromImage("space.jpg");
    var spaceBackground = new PIXI.Sprite(spaceTexture);
    stage.addChild(spaceBackground);

    // le background 1
    var texture = PIXI.Texture.fromImage("gradient1.jpg");
    var background = new PIXI.Sprite(texture);
    background.alpha = .5;
    stage.addChild(background);
    // le background 2
    var background2 = new PIXI.Sprite(texture);
    background2.position.x = 720;
    background2.alpha = .5;
    stage.addChild(background2);

    // le black background
    var blackTexture = PIXI.Texture.fromImage("black.png");
    var blackBackground = new PIXI.Sprite(blackTexture);
    blackBackground.alpha = 0;
    stage.addChild(blackBackground);

    var trackBackgroundPos = 0;
    var backBool = false;
 
    // create a renderer instance.
    var renderer = PIXI.autoDetectRenderer(720, 240);
 
    // add the renderer view element to the DOM
    document.body.appendChild(renderer.view);
 
    requestAnimFrame( animate );

    // draw le grid
    drawHorizontalLines();
    drawVerticalLines();

    // draw le hero
    var updatedX = 0;
    var updatedY = 0;
    var snapshotXPos = 0;
    var snapshotYPos = 0;
    var origXLoc = 0;
    var origYLoc = 0;

    var xMovementCheck = 0;
    var yMovementCheck = 0;

    var maxQResult = 0;

    var previousRow = 0;
    var previousMaxQResult = 0;

    var firstPass = true;
    var goalReached = false;
    var backFlushTrans = false;
    var chooseBackground = false;

    //var hero = new PIXI.Graphics();
    var texture1 = PIXI.Texture.fromImage("ship2.png");
    var hero = new PIXI.Sprite(texture1);
    constructHero();

    // draw le enemies
    //var enemy1 = new PIXI.Graphics();
    //constructEnemy(enemy1, 150, 30);
    //var enemy2 = new PIXI.Graphics();
    //constructEnemy(enemy2, 330, 210);

    // draw le goal node
    var goal = new PIXI.Graphics();
    constructGoal(goal, 860, 380);

    // create Q table, 2d array
    var qtable = new Array(9);
    for (var qxIterator = 0; qxIterator < 9; qxIterator++){
        qtable[qxIterator] = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    // create R table, 2d array
    // set rewards matrix manually
    
    var rewards = [[  -1,  0, -1,  0, -1, -1, -1, -1, -1  ],           // 1a
                   [  0,  -1,  0, -1,  0, -1, -1, -1, -1  ],           // 1b
                   [ -1,  0,  -1, -1, -1,  0, -1, -1, -1  ],           // 1c
                   [  0, -1, -1,  -1,  0, -1,  0, -1, -1  ],           // 2a
                   [ -1,  0, -1,  0,  -1,  0, -1,  0, -1  ],           // 2b
                   [ -1, -1,  0, -1,  0,  -1, -1, -1, 100 ],           // 2c
                   [ -1, -1, -1,  0, -1, -1,  -1,  0, -1  ],           // 3a
                   [ -1, -1, -1, -1,  0, -1,  0,  -1, 100 ],           // 3b
                   [ -1, -1, -1, -1, -1,  0, -1,  0, 100  ]];          // 3c

    
    // movement index
    var xMov    = [[    -1,  60,  -1,   0,   -1,  -1,  -1,  -1,  -1  ],           // 1a
                   [  -60,   -1,  60,  -1,    0,  -1,  -1,  -1,  -1  ],           // 1b
                   [   -1, -60,   -1,  -1,   -1,   0,  -1,  -1,  -1  ],           // 1c
                   [    0,  -1,  -1,   -1,   60,  -1,   0,  -1,  -1  ],           // 2a
                   [   -1,   0,  -1, -60,    -1,  60,  -1,   0,  -1  ],           // 2b
                   [   -1,  -1,   0,  -1,  -60,   -1,  -1,  -1,  0  ],            // 2c
                   [   -1,  -1,  -1,   0,   -1,  -1,   -1,  60,  -1  ],           // 3a
                   [   -1,  -1,  -1,  -1,    0,  -1, -60,   -1,  60  ],           // 3b
                   [   -1,  -1,  -1,  -1,   -1,   0,  -1, -60,   0  ]];          // 3c

    var yMov    = [[    -1,    0,  -1,   60,  -1,  -1,  -1,  -1,  -1  ],           // 1a
                   [    0,    -1,   0,   -1,  60,  -1,  -1,  -1,  -1  ],           // 1b
                   [   -1,    0,   -1,   -1,  -1,  60,  -1,  -1,  -1  ],           // 1c
                   [  -60,   -1,  -1,    -1,   0,  -1,  60,  -1,  -1  ],           // 2a
                   [   -1,  -60,  -1,    0,   -1,   0,  -1,  60,  -1  ],           // 2b
                   [   -1,   -1, -60,   -1,   0,   -1,  -1,  -1,  60  ],           // 2c
                   [   -1,   -1,  -1,  -60,  -1,  -1,   -1,   0,  -1  ],           // 3a
                   [   -1,   -1,  -1,   -1, -60,  -1,   0,   -1,   0  ],           // 3b
                   [   -1,   -1,  -1,   -1,  -1, -60,  -1,   0,   0  ]];          // 3c


    function animate() {
        requestAnimFrame( animate );

        // animate le background
        backgroundScroll();

        xMovementCheck = hero.position.x; //+ origXLoc;
        yMovementCheck = hero.position.y; //+ origYLoc;
        if ((xMovementCheck != snapshotXPos + updatedX) || (yMovementCheck != snapshotYPos + updatedY)){
            if (updatedX > 0){
                hero.position.x += 5;
            } else if (updatedX < 0) {
                hero.position.x -= 5;
            }
            if (updatedY > 0){
                hero.position.y += 5;
            } else if (updatedY < 0) {
                hero.position.y -= 5;
            }

           if (backFlushTrans == true){
                //blackBackground.alpha += .5;
                //if (blackBackground.alpha >= 1){
                //    backFlushTrans = false;
                //}
                blackBackground.alpha = 1;
                backFlushTrans = false;
            } else {
                blackBackground.alpha -= .02;
            }
        } else {
            if (goalReached == true){
                goalReached = false;
                //hero.clear();
                hero.removeStageReference();
                stage.removeChild(hero);    // bobo revisit -- also add graphic.clear, make sure references removed
                hero = new PIXI.Sprite(texture1);                
                constructHero();

                // begin background flush animation
                backFlushTrans = true;
                //backgroundFlush();
                if (chooseBackground == false){
                    background.texture = PIXI.Texture.fromImage("gradient2.jpg");
                    background2.texture = PIXI.Texture.fromImage("gradient2.jpg");
                    chooseBackground = true;
                } else {
                    background.texture = PIXI.Texture.fromImage("gradient1.jpg");
                    background2.texture = PIXI.Texture.fromImage("gradient1.jpg");   
                    chooseBackground = false;                
                }
            }

 

            // update the position for hero to travel
            snapshotXPos = hero.position.x //+ origXLoc;
            snapshotYPos = hero.position.y //+ origYLoc;

            // grid location to array mapping
            var row = gridMovementToArrayMap(snapshotXPos, snapshotYPos);

            // for whichever state we are in, find the max Q of current states actions for navigation to next state
            maxQResult = findMaxQ(row, true);

            if (firstPass == false){
                // perform Q calculation for next state (current state), store it in Q table for previous state
                performQCalculation(previousRow, previousMaxQResult, row, maxQResult);
            }

            // move hero to the state with highest found Q value from previous
            updatedX = xMov[row][maxQResult[1]];
            updatedY = yMov[row][maxQResult[1]];

            previousRow = row;
            previousMaxQResult = findMaxQ(row, false);

            firstPass = false;

            // if goal node is found, restart position of hero to beginning
            if (gridMovementToArrayMap(snapshotXPos + updatedX, snapshotYPos + updatedY) == 8){
                goalReached = true;
                firstPass = true;
            }
        }
 
        // render the stage   
        renderer.render(stage);
    }


    /*
     *
     */
    function backgroundFlush(){

    }

    /*
     *
     */
    function backgroundScroll(){
        if (backBool == false){
            background.position.x -= 20;
            trackBackgroundPos += 20;
            if (trackBackgroundPos >= 1190){
                background2.position.x -= 20;
                if (trackBackgroundPos >= 1920){
                    background.position.x = 720;
                    trackBackgroundPos = 0;
                    backBool = true;
                }
            }
        } else {
            background2.position.x -= 20;
            trackBackgroundPos += 20;
            if (trackBackgroundPos >= 1190){
                background.position.x -= 20;
                if (trackBackgroundPos >= 1920){
                    background2.position.x = 720;
                    trackBackgroundPos = 0;
                    backBool = false;
                }
            }
        }
    }


    /*
     *
     */
    function gridMovementToArrayMap(x, y){
        var row = Math.ceil(x / 60);
        var yCalc = Math.floor(y / 60);
        row += (yCalc * 3);
        return (row - 1); // mapping physical rows (1) to array (indexed from 0)
    }


    /*
     *
     */
    function performQCalculation(previousRow, previousMaxQ, row, maxQ){

        var qCalculation = rewards[previousRow][previousMaxQ[1]] + (0.8 * maxQ[0]);

        //console.log("performQCalculation: qCalculation = " + qCalculation);
        qtable[previousRow][previousMaxQ[1]] = qCalculation;

        /*
        for (i = 0; i < qtable.length; i++) {
            
            for (j = 0; j < qtable[i].length; j++) {
                console.log("qtable entries at [" + i + "][" + j + "] = " + qtable[i][j]);
            } 
        }

        console.log(" ");
        */
    }

    /*
     *
     */
    function findMaxQ(row, navigation){
        var maxQ = 0;
        var indexFound = 0;
        var qOnlyValid = false;

        if (navigation == true){
            var randomEx = Math.random();
            if (randomEx <= 0.1){
                var randomLocations = [];
                // set navigation Q to random
                for (i = 0; i < rewards[row].length; i++){
                    if (rewards[row][i] != -1){
                        randomLocations.push(i);
                    }
                }

                indexFound = randomLocations[Math.floor(Math.random() * randomLocations.length)];
                maxQ = qtable[row][indexFound];

                return [maxQ, indexFound];
            }
        }

        // look at reward table to determine valid actions for current state.
        for (i = 0; i < rewards[row].length; i++){
            // only evaluate on valid actions
            if (rewards[row][i] != -1){
                if (qtable[row][i] > maxQ){
                    // highest Q value found and index are returned
                    maxQ = qtable[row][i];

                    indexFound = i;
                    qOnlyValid = true;
                } else if (qtable[row][i] == maxQ){
                    qOnlyValid = false;
                }
            }
        }

        if (qOnlyValid == false){
            var locationsToRandomize = [];
            // second loop to determine other indexes where maxQ was found, inefficient I know
            for (i = 0; i < rewards[row].length; i++){
                // only evaluate on valid actions
                if (rewards[row][i] != -1){
                    if (qtable[row][i] == maxQ){
                        locationsToRandomize.push(i);

                    }
                }
            }

            // set indexFound to one of the locationsToRandomize values randomly
            indexFound = locationsToRandomize[Math.floor(Math.random() * locationsToRandomize.length)];
        }

        return [maxQ, indexFound];
    }

    /*
     *
     */
    function randStartingPosition(){
        // return random number between 1 and 9 (number of spaces available)
         var placement = Math.floor(Math.random()*(9)+1);
         var xAdj = placement % 3;
         var x = 0;

         if (xAdj == 0){
            x = 10;  
         } else {
            if ((placement - 1) % 3 == 0){
                x = 60 + 10;
            } else if ((placement - 2) % 3 == 0){
                x = (2 * 60) + 10;
            } 
         }

         var yAdj = Math.ceil(placement / 3);
         var y = ((yAdj - 1) * 60) + 15;

         return [x, y];
    }

    /*
     *
     */
    function constructHero(){   

        // choose starting position
        startingXY = randStartingPosition();    

        hero.position.x = startingXY[0];
        hero.position.y = startingXY[1];

        stage.addChild(hero);

        origXLoc = startingXY[0]; // hero.x;
        origYLoc = startingXY[1]; // hero.y;

        snapshotXPos = startingXY[0];
        snapshotYPos = startingXY[1];
    }

    /*
     *
     */
    function constructEnemy(e, x, y){
        // begin fill
        e.beginFill(0x000000);
        // draw a circle
        e.moveTo(x, y);
        e.drawCircle(x, y, 12);
        e.endFill();
        stage.addChild(e);   
    }

    /*
     *
     */
     function constructGoal(g, x, y){
        g.beginFill(0x000000);
        g.moveTo(x, y);
        g.drawRect(x, y, 20, 20);
        g.endFill();
        stage.addChild(g);
     }

    /*
     *  draw horizontal lines
     */
    function drawHorizontalLines() {
        var addingElements = true;
        var yPos = 60;
        var horizIteration = 0;
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics(); 
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(0,yPos);
            graphics.drawRect(0, yPos, 900, 2);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            horizIteration += 1;
            yPos += 60;
            if (horizIteration >= 6){
                addingElements = false;
            }
        }
    }

    /*
     * draw vertical lines
     */
    function drawVerticalLines(){
        addingElements = true;
        var xPos = 60;
        var vertIteration = 0;
        // draw vertical lines
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics();
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(xPos,0);
            graphics.drawRect(xPos, 0, 2, 420);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            vertIteration += 1;
            xPos += 60;
            if (vertIteration >= 15){
                addingElements = false;
            }    
        }
    }
 
    </script>
 
    </body>
</html>