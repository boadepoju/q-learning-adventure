<html>
<head>
    <title>Q-Learning Good Times</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="pixi.js"></script>
</head>
<body>
    <script>
 
    // create an new instance of a pixi stage
    var stage = new PIXI.Stage(0x66FF99);
 
    // create a renderer instance.
    var renderer = PIXI.autoDetectRenderer(900, 420);
 
    // add the renderer view element to the DOM
    document.body.appendChild(renderer.view);
 
    requestAnimFrame( animate );

    // draw le grid
    drawHorizontalLines();
    drawVerticalLines();

    // draw le hero
    var hero = new PIXI.Graphics();
    constructHero();

 
    // draw le enemies
    var enemy1 = new PIXI.Graphics();
    constructEnemy(enemy1, 150, 30);
    var enemy2 = new PIXI.Graphics();
    constructEnemy(enemy2, 330, 210);


    // draw le goal node
    var goal = new PIXI.Graphics();
    constructGoal(goal, 860, 380);


    var updatedX = 60;
    var updatedY = 60;
    var potentialMoves = new Array(60, -60, 0);
    var zeroCoords = new Array(0, 1);

    snapshotXPos = hero.x;
    snapshotYPos = hero.y;


    // create Q table, 2d array
    var qtable = new Array(9);
    for (var qxIterator = 0; qxIterator < 9; qxIterator++){
        qtable[qxIterator] = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    // create R table, 2d array
    // set rewards matrix manually
    
    var rewards = [[ -1,  0, -1,  0, -1, -1, -1, -1, -1  ],           // 1a
                   [  0, -1,  0, -1,  0, -1, -1, -1, -1  ],           // 1b
                   [ -1,  0, -1, -1, -1,  0, -1, -1, -1  ],           // 1c
                   [  0, -1, -1, -1,  0, -1,  0, -1, -1  ],           // 2a
                   [ -1,  0, -1,  0, -1,  0, -1,  0, -1  ],           // 2b
                   [ -1, -1,  0, -1,  0, -1, -1, -1, 100 ],           // 2c
                   [ -1, -1, -1,  0, -1, -1, -1,  0, -1  ],           // 3a
                   [ -1, -1, -1, -1,  0, -1,  0, -1, 100 ],           // 3b
                   [ -1, -1, -1, -1, -1,  0, -1, 0, -1   ]];          // 3c

    
    // movement index
    var xMov    = [[   -1,  60,  -1,   0,   -1,  -1,  -1,  -1,  -1  ],           // 1a
                   [  -60,  -1,  60,  -1,    0,  -1,  -1,  -1,  -1  ],           // 1b
                   [   -1, -60,  -1,  -1,   -1,   0,  -1,  -1,  -1  ],           // 1c
                   [    0,  -1,  -1,  -1,   60,  -1,   0,  -1,  -1  ],           // 2a
                   [   -1,   0,  -1, -60,   -1,  60,  -1,   0,  -1  ],           // 2b
                   [   -1,  -1,   0,  -1,  -60,  -1,  -1,  -1,  0  ],            // 2c
                   [   -1,  -1,  -1,   0,   -1,  -1,  -1,  60,  -1  ],           // 3a
                   [   -1,  -1,  -1,  -1,    0,  -1, -60,  -1,  60  ],           // 3b
                   [   -1,  -1,  -1,  -1,   -1,   0,  -1, -60,  -1  ]];          // 3c

    var yMov    = [[   -1,    0,  -1,   60,  -1,  -1,  -1,  -1,  -1  ],           // 1a
                   [    0,   -1,   0,   -1,  60,  -1,  -1,  -1,  -1  ],           // 1b
                   [   -1,    0,  -1,   -1,  -1,  60,  -1,  -1,  -1  ],           // 1c
                   [  -60,   -1,  -1,  - 1,   0,  -1,  60,  -1,  -1  ],           // 2a
                   [   -1,  -60,  -1,    0,  -1,   0,  -1,  60,  -1  ],           // 2b
                   [   -1,   -1, -60,   -1,   0,  -1,  -1,  -1,  60  ],           // 2c
                   [   -1,   -1,  -1,  -60,  -1,  -1,  -1,   0,  -1  ],           // 3a
                   [   -1,   -1,  -1,   -1, -60,  -1,   0,  -1,   0  ],           // 3b
                   [   -1,   -1,  -1,   -1,  -1, -60,  -1,   0,  -1  ]];          // 3c


    function animate() {
        requestAnimFrame( animate );

        if ((hero.x != snapshotXPos + updatedX) || (hero.y != snapshotYPos + updatedY)){
            if (updatedX > 0){
                hero.x += 2;
            } else if (updatedX < 0) {
                hero.x -= 2;
            }
            if (updatedY > 0){
                hero.y += 2;
            } else if (updatedY < 0) {
                hero.y -= 2;
            }
        } else {
            // update the position for hero to travel
            snapshotXPos = hero.x;
            snapshotYPos = hero.y;

            // grid location to array mapping
            var row = Math.ceil(snapshotXPos / 60);
            var yCalc = Math.floor(snapshotYPos / 60);
            row += (yCalc * 3);
            //console.log("grid row value = " + row);
            
            // for whichever state we are in, find the max Q of next state's actions
            var maxQResult = findMaxQ(row);
            console.log("finished findMaxQ for row " + row);

            // perform Q calculation, store it in Q table
            var qCalculation = rewards[row][maxQResult[1]] + (0.8 * maxQResult[0]);

            if (row == 5 || row == 7){
                for (i = 0; i < rewards[row].length; i++){
                    console.log("reward @ index " + i + " = " + rewards[row][i]);
                }
                console.log("qCalc: foundIndex = " + maxQResult[1]);
                console.log("qCalc: reward found = " + rewards[row][maxQResult[1]]);
                console.log("qCalc: qCalculation = " + qCalculation);
            }



            qtable[row][maxQResult[1]] = qCalculation;

            // move hero to the state with highest found Q value from previous
            updatedX = xMov[row][maxQResult[1]];
            updatedY = yMov[row][maxQResult[1]];



/*
            // border tiles, hero cannot travel beyond map
            var hitBorderX = false;
            var hitBorderY = false;

            if (snapshotXPos < 60){
                // left border
                // remove -60 from options
                var leftBorderPotential = new Array(60, 0);
                updatedX = leftBorderPotential[Math.floor(Math.random() * leftBorderPotential.length)];
                hitBorderX = true;
            } 
            if (snapshotYPos < 60){
                // top border
                // remove -60 from options
                var topBorderPotential = new Array(60, 0);
                updatedY = topBorderPotential[Math.floor(Math.random() * topBorderPotential.length)];
                hitBorderY = true;
            }

            if (snapshotXPos > 780){
                // right border
                var rightBorderPotential = new Array(-60, 0);
                updatedX = rightBorderPotential[Math.floor(Math.random() * rightBorderPotential.length)];
                hitBorderX = true;             
            }

            if (snapshotYPos > 300){
                // bottom border
                var bottomBorderPotential = new Array(-60, 0);
                updatedY = bottomBorderPotential[Math.floor(Math.random() * bottomBorderPotential.length)];
                hitBorderY = true;
            }

            if (hitBorderX == false){
                updatedX = potentialMoves[Math.floor(Math.random() * potentialMoves.length)];                
            }
            if (hitBorderY == false){
                updatedY = potentialMoves[Math.floor(Math.random() * potentialMoves.length)];            
            }
            
            // if both coordinates aren't equal to 0, choose between one and 0 it out
            // so that hero can't move diagonally
            if ((updatedX != 0) && (updatedY != 0)){
                zeroCoord = zeroCoords[Math.floor(Math.random() * zeroCoords.length)];
                if (zeroCoord == 0){
                    updatedY = 0;
                } else {
                    updatedX = 0;
                }
            } */
        }
 
        // render the stage   
        renderer.render(stage);
    }

    /*
     *
     */
    function findMaxQ(row){
        var maxQ = 0;
        var indexFound = 0;
        var qOnlyValid = false;

        if (row == 5 || row == 7){                                      // debug only, remove
            console.log("Entered row 5");                   // debug only, remove
        }                                                   // debug only, remove

        // look at reward table to determine valid actions for current state.
        for (i = 0; i < rewards[row].length; i++){
            // only evaluate on valid actions
            if (rewards[row][i] != -1){
                //console.log("bobo valid action locations = " + i);
                if (qtable[row][i] > maxQ){
                    // highest Q value found and index are returned
                    maxQ = qtable[row][i];
                    indexFound = i;
                    qOnlyValid = true;
                } else if (qtable[row][i] == maxQ){
                    qOnlyValid = false;
                }
            }
        }

       if (row == 5 || row == 7){
            console.log("maxQ found = " + maxQ);
        }

        if (qOnlyValid == false){
            //console.log("bobo got to qOnlyValid");
            var locationsToRandomize = [];
            // second loop to determine other indexes where maxQ was found, inefficient I know
            for (i = 0; i < rewards[row].length; i++){
                // only evaluate on valid actions
                if (rewards[row][i] != -1){
                    console.log("rewards[row][i] = " + rewards[row][i]);
                    console.log("qtable[row][i] = " + qtable[row][i]);
                    if (qtable[row][i] == maxQ){
                        locationsToRandomize.push(i);
                    }
                }
            }

            //if (row == 5 || row == 7){
                for (i = 0; i < locationsToRandomize.length; i++){
                    console.log("locationsToRandomize at index " + i + " = " + locationsToRandomize[i]);
                }
            //}

            // set indexFound to one of the locationsToRandomize values randomly
            indexFound = locationsToRandomize[Math.floor(Math.random() * locationsToRandomize.length)];
            //console.log("findMaxQ: indexFound = " + indexFound);
        }

        console.log("findMaxQ: maxQ = " + maxQ);
        console.log("findMaxQ: indexFound = " + indexFound);
        console.log("findMaxQ: row = " + row);

        return [maxQ, indexFound];
    }

    /*
     *
     */
    function constructHero(){   
        // begin a green fill..
        hero.beginFill(0x000000);
        // draw a triangle using lines
        hero.moveTo(30,15);
        hero.lineTo(20, 45);
        hero.lineTo(40, 45);
        // end the fill
        hero.endFill();
        // add it the stage so we see it on our screens..
        stage.addChild(hero);
    }

    /*
     *
     */
    function constructEnemy(e, x, y){
        // begin fill
        e.beginFill(0x000000);
        // draw a circle
        e.moveTo(x, y);
        e.drawCircle(x, y, 12);
        e.endFill();
        stage.addChild(e);   
    }

    /*
     *
     */
     function constructGoal(g, x, y){
        g.beginFill(0x000000);
        g.moveTo(x, y);
        g.drawRect(x, y, 20, 20);
        g.endFill();
        stage.addChild(g);
     }

    /*
     *  draw horizontal lines
     */
    function drawHorizontalLines() {
        var addingElements = true;
        var yPos = 60;
        var horizIteration = 0;
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics(); 
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(0,yPos);
            graphics.drawRect(0, yPos, 900, 2);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            horizIteration += 1;
            yPos += 60;
            if (horizIteration >= 6){
                addingElements = false;
            }
        }
    }

    /*
     * draw vertical lines
     */
    function drawVerticalLines(){
        addingElements = true;
        var xPos = 60;
        var vertIteration = 0;
        // draw vertical lines
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics();
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(xPos,0);
            graphics.drawRect(xPos, 0, 2, 420);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            vertIteration += 1;
            xPos += 60;
            if (vertIteration >= 15){
                addingElements = false;
            }    
        }
    }
 
    </script>
 
    </body>
</html>