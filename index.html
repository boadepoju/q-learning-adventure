<html>
<head>
    <title>Q-Learning Good Times</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="pixi.js"></script>
</head>
<body>
    <script>
 
    // create an new instance of a pixi stage
    var stage = new PIXI.Stage(0x66FF99);
 
    // create a renderer instance.
    var renderer = PIXI.autoDetectRenderer(900, 420);
 
    // add the renderer view element to the DOM
    document.body.appendChild(renderer.view);
 
    requestAnimFrame( animate );

    // draw le grid
    drawHorizontalLines();
    drawVerticalLines();

    // draw le hero
    var updatedX = 0;
    var updatedY = 0;
    var snapshotXPos = 0;
    var snapshotYPos = 0;
    var origXLoc = 0;
    var origYLoc = 0;

    var xMovementCheck = 0;
    var yMovementCheck = 0;

    var goalReached = false;

    var hero = new PIXI.Graphics();
    constructHero();

 
    // draw le enemies
    var enemy1 = new PIXI.Graphics();
    constructEnemy(enemy1, 150, 30);
    var enemy2 = new PIXI.Graphics();
    constructEnemy(enemy2, 330, 210);


    // draw le goal node
    var goal = new PIXI.Graphics();
    constructGoal(goal, 860, 380);




    // create Q table, 2d array
    var qtable = new Array(9);
    for (var qxIterator = 0; qxIterator < 9; qxIterator++){
        qtable[qxIterator] = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    // create R table, 2d array
    // set rewards matrix manually
    
    var rewards = [[ -1,  0, -1,  0, -1, -1, -1, -1, -1  ],           // 1a
                   [  0, -1,  0, -1,  0, -1, -1, -1, -1  ],           // 1b
                   [ -1,  0, -1, -1, -1,  0, -1, -1, -1  ],           // 1c
                   [  0, -1, -1, -1,  0, -1,  0, -1, -1  ],           // 2a
                   [ -1,  0, -1,  0, -1,  0, -1,  0, -1  ],           // 2b
                   [ -1, -1,  0, -1,  0, -1, -1, -1, 100 ],           // 2c
                   [ -1, -1, -1,  0, -1, -1, -1,  0, -1  ],           // 3a
                   [ -1, -1, -1, -1,  0, -1,  0, -1, 100 ],           // 3b
                   [ -1, -1, -1, -1, -1,  0, -1, 0, -1   ]];          // 3c

    
    // movement index
    var xMov    = [[   -1,  60,  -1,   0,   -1,  -1,  -1,  -1,  -1  ],           // 1a
                   [  -60,  -1,  60,  -1,    0,  -1,  -1,  -1,  -1  ],           // 1b
                   [   -1, -60,  -1,  -1,   -1,   0,  -1,  -1,  -1  ],           // 1c
                   [    0,  -1,  -1,  -1,   60,  -1,   0,  -1,  -1  ],           // 2a
                   [   -1,   0,  -1, -60,   -1,  60,  -1,   0,  -1  ],           // 2b
                   [   -1,  -1,   0,  -1,  -60,  -1,  -1,  -1,  0  ],            // 2c
                   [   -1,  -1,  -1,   0,   -1,  -1,  -1,  60,  -1  ],           // 3a
                   [   -1,  -1,  -1,  -1,    0,  -1, -60,  -1,  60  ],           // 3b
                   [   -1,  -1,  -1,  -1,   -1,   0,  -1, -60,  -1  ]];          // 3c

    var yMov    = [[   -1,    0,  -1,   60,  -1,  -1,  -1,  -1,  -1  ],           // 1a
                   [    0,   -1,   0,   -1,  60,  -1,  -1,  -1,  -1  ],           // 1b
                   [   -1,    0,  -1,   -1,  -1,  60,  -1,  -1,  -1  ],           // 1c
                   [  -60,   -1,  -1,  - 1,   0,  -1,  60,  -1,  -1  ],           // 2a
                   [   -1,  -60,  -1,    0,  -1,   0,  -1,  60,  -1  ],           // 2b
                   [   -1,   -1, -60,   -1,   0,  -1,  -1,  -1,  60  ],           // 2c
                   [   -1,   -1,  -1,  -60,  -1,  -1,  -1,   0,  -1  ],           // 3a
                   [   -1,   -1,  -1,   -1, -60,  -1,   0,  -1,   0  ],           // 3b
                   [   -1,   -1,  -1,   -1,  -1, -60,  -1,   0,  -1  ]];          // 3c


    function animate() {
        requestAnimFrame( animate );

        xMovementCheck = hero.x + origXLoc;
        yMovementCheck = hero.y + origYLoc;
        if ((xMovementCheck != snapshotXPos + updatedX) || (yMovementCheck != snapshotYPos + updatedY)){
            if (updatedX > 0){
                hero.x += 5;
            } else if (updatedX < 0) {
                hero.x -= 5;
            }
            if (updatedY > 0){
                hero.y += 5;
            } else if (updatedY < 0) {
                hero.y -= 5;
            }
        } else {
            if (goalReached == true){
                goalReached = false;
                hero.clear();
                hero.removeStageReference();
                stage.removeChild(hero);    // bobo revisit -- also add graphic.clear, make sure references removed
                hero = new PIXI.Graphics();
                constructHero();
            }

            // update the position for hero to travel

            //console.log("hero.x = " + hero.x);
            //console.log("hero.y = " + hero.y);

            snapshotXPos = hero.x + origXLoc;
            snapshotYPos = hero.y + origYLoc;

            // grid location to array mapping
            var row = gridMovementToArrayMap(snapshotXPos, snapshotYPos);
            
            // for whichever state we are in, find the max Q of next state's actions
            var maxQResult = findMaxQ(row);

            // perform Q calculation, store it in Q table
            performQCalculation(row, maxQResult);

            // move hero to the state with highest found Q value from previous
            updatedX = xMov[row][maxQResult[1]];
            updatedY = yMov[row][maxQResult[1]];

            // if goal node is found, restart position of hero to beginning
            if (gridMovementToArrayMap(snapshotXPos + updatedX, snapshotYPos + updatedY) == 8){
                goalReached = true;



                // iterate through qtable to observe whether values are suitable
                for (i = 0; i < qtable.length; i++) {
                    
                    for (j = 0; j < qtable[i].length; j++) {
                        console.log("qtable entries at [" + i + "][" + j + "] = " + qtable[i][j]);
                    } 
                }
                
            }
        }
 
        // render the stage   
        renderer.render(stage);
    }






    /*
     *
     */
    function gridMovementToArrayMap(x, y){
        var row = Math.ceil(x / 60);
        var yCalc = Math.floor(y / 60);
        row += (yCalc * 3);
        //console.log("gridMovementToArrayMap: x = " + x);
        //console.log("gridMovementToArrayMap: y = " + y);
        //console.log("gridMovementToArrayMap: row = " + (row - 1));
        return (row - 1); // mapping physical rows (1) to array (indexed from 0)
    }


    /*
     *
     */
    function performQCalculation(row, maxQ){
        var qCalculation = rewards[row][maxQ[1]] + (0.8 * maxQ[0]);
        qtable[row][maxQ[1]] = qCalculation;
    }

    /*
     *
     */
    function findMaxQ(row){
        var maxQ = 0;
        var indexFound = 0;
        var qOnlyValid = false;

        // look at reward table to determine valid actions for current state.
        for (i = 0; i < rewards[row].length; i++){
            // only evaluate on valid actions
            if (rewards[row][i] != -1){
                if (qtable[row][i] > maxQ){
                    // highest Q value found and index are returned
                    maxQ = qtable[row][i];
                    indexFound = i;
                    qOnlyValid = true;
                } else if (qtable[row][i] == maxQ){
                    qOnlyValid = false;
                }
            }
        }

        if (qOnlyValid == false){
            var locationsToRandomize = [];
            // second loop to determine other indexes where maxQ was found, inefficient I know
            for (i = 0; i < rewards[row].length; i++){
                // only evaluate on valid actions
                if (rewards[row][i] != -1){
                    if (qtable[row][i] == maxQ){
                        locationsToRandomize.push(i);
                    }
                }
            }

            // set indexFound to one of the locationsToRandomize values randomly
            indexFound = locationsToRandomize[Math.floor(Math.random() * locationsToRandomize.length)];
        }

        return [maxQ, indexFound];
    }

    /*
     *
     */
    function randStartingPosition(){
        // return random number between 1 and 9 (number of spaces available)
         var placement = Math.floor(Math.random()*(9)+1);
         var xAdj = placement % 3;
         var x = 0;

         if (xAdj == 0){
            x = 30;  
         } else {
            if ((placement - 1) % 3 == 0){
                x = 60 + 30;
            } else if ((placement - 2) % 3 == 0){
                x = (2 * 60) + 30;
            } 
         }

         var yAdj = Math.ceil(placement / 3);
         var y = ((yAdj - 1) * 60) + 15;

         return [x, y];
    }

    /*
     *
     */
    function constructHero(){   
        // begin a green fill..
        hero.beginFill(0x000000);

        // choose starting position
        startingXY = randStartingPosition()

        // draw a triangle using lines
        hero.moveTo(startingXY[0],startingXY[1]);
        hero.lineTo(startingXY[0] - 10, startingXY[1] + 30);
        hero.lineTo(startingXY[0] + 10, startingXY[1] + 30);

        // end the fill
        hero.endFill();
        // add it the stage so we see it on our screens..
        stage.addChild(hero);

        origXLoc = startingXY[0]; // hero.x;
        origYLoc = startingXY[1]; // hero.y;


        snapshotXPos = startingXY[0];
        snapshotYPos = startingXY[1];

        //console.log("constructHero: origXLoc = " + origXLoc);
        //console.log("constructHero: origYLoc = " + origYLoc);
    }

    /*
     *
     */
    function constructEnemy(e, x, y){
        // begin fill
        e.beginFill(0x000000);
        // draw a circle
        e.moveTo(x, y);
        e.drawCircle(x, y, 12);
        e.endFill();
        stage.addChild(e);   
    }

    /*
     *
     */
     function constructGoal(g, x, y){
        g.beginFill(0x000000);
        g.moveTo(x, y);
        g.drawRect(x, y, 20, 20);
        g.endFill();
        stage.addChild(g);
     }

    /*
     *  draw horizontal lines
     */
    function drawHorizontalLines() {
        var addingElements = true;
        var yPos = 60;
        var horizIteration = 0;
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics(); 
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(0,yPos);
            graphics.drawRect(0, yPos, 900, 2);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            horizIteration += 1;
            yPos += 60;
            if (horizIteration >= 6){
                addingElements = false;
            }
        }
    }

    /*
     * draw vertical lines
     */
    function drawVerticalLines(){
        addingElements = true;
        var xPos = 60;
        var vertIteration = 0;
        // draw vertical lines
        while (addingElements == true){
            // draw lines to create grid
            var graphics = new PIXI.Graphics();
            // begin a green fill..
            graphics.beginFill(0x000000);
            // draw a triangle using lines
            graphics.moveTo(xPos,0);
            graphics.drawRect(xPos, 0, 2, 420);
            // end the fill
            graphics.endFill();
            // add it the stage so we see it on our screens..
            stage.addChild(graphics);
            vertIteration += 1;
            xPos += 60;
            if (vertIteration >= 15){
                addingElements = false;
            }    
        }
    }
 
    </script>
 
    </body>
</html>